[["getting-familiar-with-the-mmrf-commpass-datasets-in-r.html", "Chapter 3 Getting familiar with the MMRF CoMMpass datasets in R 3.1 Setup a working directory 3.2 Explore data with the R tidyverse 3.3 Represent data with ggplot2 3.4 Merge information across tables 3.5 Survival analysis and Cox regression 3.6 Kaplan-Meier curves from survival data", " Chapter 3 Getting familiar with the MMRF CoMMpass datasets in R This codebook will rely on data from the MMRF CoMMpass data. Register as a researcher and download the following data from release IA21 https://research.themmrf.org/ in a directory named MMRF_IA21. CoMMpass_IA21_FlatFile_Dictionaries.tar.gz # decompress this folder CoMMpass_IA21_FlatFiles.tar.gz # decompress 3.1 Setup a working directory At this point, we assume you have a directory named MMRF_IA21 on your computer, which contains the analysis from TGEN’s Phoenix pipeline (https://github.com/tgen/phoenix/). We will explore the available clinical annotation for samples and patients. library(tidyverse) list.files(&quot;MMRF_IA21&quot;) If the output of the above command is an error, you may not be working from the expected directory. You can fix that by changing your working directory with the getwd and setwd pair of commands, or manually specify the path to “MMRF_IA21” files in the next lines of code. # un-comment (remove # sign) and adjust the following line with your own working directory # setwd(&quot;~/Documents/MyProject&quot;) getwd() ## [1] &quot;/Users/jean-baptiste/Dropbox (Partners HealthCare)/2_Projects/MM_R_Codebook&quot; 3.2 Explore data with the R tidyverse Tables from the MMRF database are usually in the tab-separated values format and can be read with the read.table (base R) or read_tsv function (tidyverse). In this codebook, we chose to use the tidyverse packages. mmrf &lt;- read_tsv(&quot;MMRF_IA21/CoMMpass_IA21_FlatFiles/MMRF_CoMMpass_IA21_PER_PATIENT.tsv&quot;) ## Rows: 1143 Columns: 91 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;\\t&quot; ## chr (27): PUBLIC_ID, D_PT_DIDPATIENTCOM, D_PT_PRIMARYREASON, D_PT_CAUSEOFDEA... ## dbl (63): D_PT_ic_day, D_PT_deathdy, D_PT_lastdy, D_PT_complete, D_PT_discon... ## lgl (1): DEMOG_NATIVEHAWAIIA ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. Use the combinations of functions ncol, nrow, dim, class, etc. to explore the dataset: nrow(mmrf) # number of rows ncol(mmrf) # number of columns sapply(mmrf, class) # for each column of mmrf (sapply function), report the class of the variable (class function) () colnames(mmrf) # get column names Use basic R functions to extract information from the columns: ## extract variables # variables can be extracted with the $ sign and a direct reference to the column name: head(mmrf$PUBLIC_ID) # first values tail(mmrf$PUBLIC_ID) # last values mmrf$PUBLIC_ID # all values mmrf[[&quot;PUBLIC_ID&quot;]] # specify column as a variable itself (can replace &quot;PUBLIC_ID&quot; with a variable pointing to &quot;PUBLIC_ID&quot;) ## subset parts of the table mmrf[1:5, 1:4] # this extracts the first 5 rows and 4 variables mmrf[1:5, c(&quot;PUBLIC_ID&quot;, &quot;D_PT_deathdy&quot;)] # this extracts the first 5 values for variables PUBLIC_ID and D_PT_deathdy Numeric variables can also be treated with standard R functions mmrf$D_PT_age # what are the values for age summary(mmrf$D_PT_age) # what are range; quantiles; and summary values quantile(mmrf$D_PT_age, probs = c(.025, .975)) # check for quantiles of interest sum(is.na(mmrf$D_PT_age)) # is there any NA values? mean(mmrf$D_PT_age) # compute the mean. mean(mmrf$D_PT_age, na.rm=TRUE) would ignore NA values when computing the mean Other useful functions include: median, sd, min, max, … Character and categorical variables should also be checked for possible values and inconsistencies: table(mmrf$D_PT_race, useNA = &quot;ifany&quot;) # what are affected values for a given variable (and their number of occurences) any(duplicated(mmrf$PUBLIC_ID)) # is there any duplicated values mmrf$PUBLIC_ID[duplicated(mmrf$PUBLIC_ID)] # if there was any duplicated values length(unique(mmrf$PUBLIC_ID)) # how many uniques values are in the table for this variable sort(mmrf$PUBLIC_ID) # return values in an alphabetical order Another grammar can be used in R and will become more powerful with tidyverse functions. Using |&gt; , (or, almost equivalent, %&gt;%),first arguments of functions (on the right of the |&gt;) will be fed with the output of the previous element (on the left of the |&gt;), almost like database query languages and grammar. This will facilitate applying list of functions to a single data table. c(1, 2, 3, 4) |&gt; sum() # is equivalent to: sum(c(1, 2, 3, 4)) For example, to list and count the causes of death in the mmrf table, we could use: mmrf |&gt; group_by(D_PT_CAUSEOFDEATH) |&gt; count() ## # A tibble: 4 × 2 ## # Groups: D_PT_CAUSEOFDEATH [4] ## D_PT_CAUSEOFDEATH n ## &lt;chr&gt; &lt;int&gt; ## 1 Disease Progression 22 ## 2 Disease progression 213 ## 3 Other 182 ## 4 &lt;NA&gt; 726 It is also easy to assign the output of a chain of instructions to a new variable: Here group_by will force the next layer to be applied to each unique combination of the categorical values specify in the grouping arguments: mmrf |&gt; count() ## # A tibble: 1 × 1 ## n ## &lt;int&gt; ## 1 1143 death.causes &lt;- mmrf |&gt; group_by(D_PT_CAUSEOFDEATH) |&gt; count() death.causes ## # A tibble: 4 × 2 ## # Groups: D_PT_CAUSEOFDEATH [4] ## D_PT_CAUSEOFDEATH n ## &lt;chr&gt; &lt;int&gt; ## 1 Disease Progression 22 ## 2 Disease progression 213 ## 3 Other 182 ## 4 &lt;NA&gt; 726 stats.age &lt;- mmrf |&gt; group_by(D_PT_race, D_PT_gender) |&gt; summarise(median_age=median(D_PT_age), min_age=min(D_PT_age), max_age=max(D_PT_age)) |&gt; # summarize to flatten the dataframe mutate(range=max_age-min_age) |&gt; # mutate to define a new column mutate(text=str_c(&quot;median=&quot;, median_age,&quot;\\n&quot;, &quot;(&quot;, max_age, &quot;-&quot;, min_age, &quot;)&quot;)) ## `summarise()` has grouped output by &#39;D_PT_race&#39;. You can override using the ## `.groups` argument. stats.age ## # A tibble: 11 × 7 ## # Groups: D_PT_race [6] ## D_PT_race D_PT_gender median_age min_age max_age range text ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 1 65 27 93 66 &quot;median=65\\n(93-27)&quot; ## 2 1 2 66 36 91 55 &quot;median=66\\n(91-36)&quot; ## 3 2 1 65 32 87 55 &quot;median=65\\n(87-32)&quot; ## 4 2 2 61 34 90 56 &quot;median=61\\n(90-34)&quot; ## 5 3 2 53 53 53 0 &quot;median=53\\n(53-53)&quot; ## 6 4 1 59 46 72 26 &quot;median=59\\n(72-46)&quot; ## 7 4 2 63 42 71 29 &quot;median=63\\n(71-42)&quot; ## 8 6 1 62.5 39 79 40 &quot;median=62.5\\n(79-39)&quot; ## 9 6 2 64 50 74 24 &quot;median=64\\n(74-50)&quot; ## 10 NA 1 58 38 65 27 &quot;median=58\\n(65-38)&quot; ## 11 NA 2 58 38 66 28 &quot;median=58\\n(66-38)&quot; Most useful functions include select (to select variables), filter (to select rows, or observations), mutate (to define new variables), and summarize to compute summary statistics. More complete descriptions are available in the cheat sheets provided by Rstudio: https://rstudio.github.io/cheatsheets/tidyr.pdf and https://rstudio.github.io/cheatsheets/data-transformation.pdf mmrf |&gt; filter(D_PT_age &gt;= 45 &amp; D_PT_race==1) |&gt; group_by(D_PT_gender) |&gt; summarise(median_age=median(D_PT_age)) ## # A tibble: 2 × 2 ## D_PT_gender median_age ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 65 ## 2 2 66 3.3 Represent data with ggplot2 The ggplot2 package is a commonly used library which provides functions to visually represent data sets. Rstudio provides a very useful cheat sheet for ggplot2 function. https://rstudio.github.io/cheatsheets/data-visualization.pdf The grammar for ggplot2 is generally (1) ggplot() call to specify a data frame to work with, then (2) aes() calls to specify the variables used in axes and layers, and (3) graphical layers separated by a + sign. #install.packages(&quot;RColorBrewer&quot;) if needed library(RColorBrewer) library(ggplot2) ggplot(mmrf, aes(D_PT_age)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # ggplot(mmrf, aes(D_PT_age)) + # geom_violin() ggplot(mmrf, aes(D_PT_CAUSEOFDEATH, D_PT_age)) + geom_violin() + geom_boxplot(width=0.2) + geom_jitter(alpha=0.3) # represent the information ggplot(death.causes, aes(x = D_PT_CAUSEOFDEATH, y = n)) + geom_bar(stat=&quot;identity&quot;) In the above function call, death.causes represents a data frame, D_PT_CAUSEOFDEATH and n map x and y axes to column names (variables) of the data frame, while the geom_bar following the + sign specifies graphical layers of figure. We could change axis, theme, colors… ggplot(death.causes, aes(x = D_PT_CAUSEOFDEATH, y = n, fill=D_PT_CAUSEOFDEATH)) + # figure layer geom_bar(stat=&quot;identity&quot;) + # axis layer scale_y_continuous(trans=&quot;pseudo_log&quot;, limits=c(NA, 1000), breaks=c(0, 1, 10, 1000)) + scale_fill_manual(values=brewer.pal(n=4, &quot;Set1&quot;)) + # axis labels labs(x=&quot;Cause of death&quot;, y=&quot;Number of observations&quot;, fill=&quot;Cause of death&quot;) + # graphical settings (independent of the data values) theme_bw() + theme(legend.position=&quot;top&quot;) 3.4 Merge information across tables In our scenario, we would like to add the survival data for each patient with is saved in another table (MMRF_CoMMpass_IA21_STAND_ALONE_SURVIVAL.tsv). Luckily, patients from both tables can be matched by their PUBLIC_ID key value. mmrf.survival &lt;- read_tsv(&quot;MMRF_IA21/CoMMpass_IA21_FlatFiles/MMRF_CoMMpass_IA21_STAND_ALONE_SURVIVAL.tsv&quot;) ## Rows: 1143 Columns: 226 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;\\t&quot; ## chr (1): PUBLIC_ID ## dbl (217): deathdy, lstalive, lvisitdy, maxline, linesdy1, linesdy2, linesdy... ## lgl (8): trtstdy, fltendy, pfsendy, osendy, frendy, ttfendy, t2lendy, t3lendy ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # keep only useful variables for this particular analysis mmrf.survival &lt;- mmrf.survival |&gt; select(PUBLIC_ID, ttcpfs1, censpfs1, ttcos, censos) Basic data quality checks should be performed again head(mmrf.survival) sapply(mmrf.survival, class) sapply(mmrf.survival, summary) table(is.na(mmrf.survival$ttcpfs1)) table(mmrf$PUBLIC_ID %in% mmrf.survival$PUBLIC_ID) # how many of mmrf&#39;s public ID also have survival data all(sort(mmrf$PUBLIC_ID) == sort(mmrf.survival$PUBLIC_ID)) # are IDs perfectly matching, etc Data tables can be combined based on unique key identifiers that match across tables, in operations that are called joins (https://en.wikipedia.org/wiki/Join_(SQL)). Here, we want to study only IDs which are found in both the sociodemographics table, and the survival table, we will use an inner_join. Because each table has only 1 row per unique PUBLIC_ID value, the joint table will also have only 1 row per patient. mmrf.socio.survival &lt;- inner_join(mmrf, mmrf.survival, by = c(&quot;PUBLIC_ID&quot;=&quot;PUBLIC_ID&quot;)) # DO NOT use bind_rows/cols to combine information from the same observation KEY IDs across tables # bind_rows(head(mmrf), head(mmrf.survival)) |&gt; View() # this may miss matching information # bind_cols(head(mmrf[,1:5]), head(mmrf.survival |&gt; arrange(PUBLIC_ID))) |&gt; View() # this may assign wrong values to patients if they are not exactly in the same order mmrf.socio.survival[1:5, c(&quot;PUBLIC_ID&quot;, &quot;censos&quot;)] ## # A tibble: 5 × 2 ## PUBLIC_ID censos ## &lt;chr&gt; &lt;dbl&gt; ## 1 MMRF_1014 0 ## 2 MMRF_1017 1 ## 3 MMRF_1024 0 ## 4 MMRF_1038 1 ## 5 MMRF_1033 0 3.5 Survival analysis and Cox regression Survival analysis are usually performed with the survival R package. In order to produce Kaplan-Meier graphs, we can leverage the survminer library which wraps ggplot2 and adds extremely useful functions for figures in survival analysis. Similar to linear (lm(y~x, data=df)) and logistic regressions, (glm(outcome~x, data=df, family=binomial), Cox proportional hazard models are fitted with a R formula: library(survival) library(survminer) ## Loading required package: ggpubr ## ## Attaching package: &#39;survminer&#39; ## The following object is masked from &#39;package:survival&#39;: ## ## myeloma # create an Age_Class variable that separates patients under 65 years old mmrf.socio.survival &lt;- mmrf.socio.survival |&gt; mutate(Age_Class = D_PT_age &gt;= 65) # model the PFS1 based on that age category coxph( Surv(ttcpfs1, censpfs1) ~ Age_Class, data = mmrf.socio.survival ) ## Call: ## coxph(formula = Surv(ttcpfs1, censpfs1) ~ Age_Class, data = mmrf.socio.survival) ## ## coef exp(coef) se(coef) z p ## Age_ClassTRUE 0.52148 1.68453 0.09215 5.659 1.52e-08 ## ## Likelihood ratio test=32.25 on 1 df, p=1.356e-08 ## n= 1143, number of events= 478 Cox models can be saved into regular R variables (obj &lt;- coxph(...)), and base R functions such as summary also apply to these in order to extract model estimates, confidence intervals around the estimates, and p-values for the desired statistical test. mmrf.pfs1 &lt;- coxph( Surv(ttcpfs1, censpfs1) ~ Age_Class, data = mmrf.socio.survival ) # model estimates and p values summary( mmrf.pfs1 ) ## Call: ## coxph(formula = Surv(ttcpfs1, censpfs1) ~ Age_Class, data = mmrf.socio.survival) ## ## n= 1143, number of events= 478 ## ## coef exp(coef) se(coef) z Pr(&gt;|z|) ## Age_ClassTRUE 0.52148 1.68453 0.09215 5.659 1.52e-08 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## exp(coef) exp(-coef) lower .95 upper .95 ## Age_ClassTRUE 1.685 0.5936 1.406 2.018 ## ## Concordance= 0.569 (se = 0.012 ) ## Likelihood ratio test= 32.25 on 1 df, p=1e-08 ## Wald test = 32.03 on 1 df, p=2e-08 ## Score (logrank) test = 32.75 on 1 df, p=1e-08 # Approximate confidence intervals in the exponential space exp(confint( mmrf.pfs1 )) ## 2.5 % 97.5 % ## Age_ClassTRUE 1.406178 2.01797 3.6 Kaplan-Meier curves from survival data The survminer conveniently offers a Kaplan-Meier curve function wrapped around ggplot2. Luckily, and as usual with commonly used functions, we do not need to code these from scratch with basic ggplot2 layers. # Basic survival curves mmrf.pfs1.survfit &lt;- survfit(Surv(ttcpfs1, censpfs1) ~ Age_Class, data = mmrf.socio.survival) ggsurvplot(mmrf.pfs1.survfit, data = mmrf.socio.survival) The ggsurvplot function has many arguments (try help(ggsurvplot) or ?ggsurvplot) that we can leverage to display more information on the figure, to transform the time axis unit from days to year: survplot.pfs &lt;- ggsurvplot(mmrf.pfs1.survfit, data=mmrf.socio.survival, title=&quot;PFS&quot;, pval = TRUE, risk.table = TRUE, surv.median.line = &quot;hv&quot;, xscale=&quot;d_y&quot;, break.x.by=365.25, xlim=c(0, 7*365.25)) survplot.pfs To save these composite ggplot2 objects into pdf files, you can use the: pdf(&quot;MyFirstKaplanMeier.pdf&quot;) # create file print(survplot.pfs) dev.off() # close file ## quartz_off_screen ## 2 In general, simple ggplot2 figures can be written to png/pdf/etc. files with the ggsave function. Finally, tables can be saved with the write_ set of functions: write_tsv(mmrf.socio.survival, &quot;mmrf_demog_survival_merge.tsv&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
